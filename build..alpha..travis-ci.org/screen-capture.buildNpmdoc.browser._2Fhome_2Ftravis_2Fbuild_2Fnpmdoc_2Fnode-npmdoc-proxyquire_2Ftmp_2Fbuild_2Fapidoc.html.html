<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/thlorenz/proxyquire#readme">proxyquire (v1.7.11)</a>
</h1>
<h4>Proxies nodejs require in order to allow overriding dependencies during testing.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxyquire">module proxyquire</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire">
            function <span class="apidocSignatureSpan"></span>proxyquire
            <span class="apidocSignatureSpan">(parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire._disableCache">
            function <span class="apidocSignatureSpan">proxyquire.</span>_disableCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire._disableGlobalCache">
            function <span class="apidocSignatureSpan">proxyquire.</span>_disableGlobalCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire._disableModuleCache">
            function <span class="apidocSignatureSpan">proxyquire.</span>_disableModuleCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire._overrideExtensionHandlers">
            function <span class="apidocSignatureSpan">proxyquire.</span>_overrideExtensionHandlers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire._require">
            function <span class="apidocSignatureSpan">proxyquire.</span>_require
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire._withoutCache">
            function <span class="apidocSignatureSpan">proxyquire.</span>_withoutCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.callThru">
            function <span class="apidocSignatureSpan">proxyquire.</span>callThru
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.compat">
            function <span class="apidocSignatureSpan">proxyquire.</span>compat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.load">
            function <span class="apidocSignatureSpan">proxyquire.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.noCallThru">
            function <span class="apidocSignatureSpan">proxyquire.</span>noCallThru
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.noPreserveCache">
            function <span class="apidocSignatureSpan">proxyquire.</span>noPreserveCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.preserveCache">
            function <span class="apidocSignatureSpan">proxyquire.</span>preserveCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire_error">
            function <span class="apidocSignatureSpan">proxyquire.</span>proxyquire_error
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxyquire.</span>is</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxyquire.</span>proxyquire.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxyquire.is">module proxyquire.is</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.is.Arguments">
            function <span class="apidocSignatureSpan">proxyquire.is.</span>Arguments
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.is.Date">
            function <span class="apidocSignatureSpan">proxyquire.is.</span>Date
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.is.Function">
            function <span class="apidocSignatureSpan">proxyquire.is.</span>Function
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.is.Number">
            function <span class="apidocSignatureSpan">proxyquire.is.</span>Number
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.is.Object">
            function <span class="apidocSignatureSpan">proxyquire.is.</span>Object
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.is.RegExp">
            function <span class="apidocSignatureSpan">proxyquire.is.</span>RegExp
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.is.String">
            function <span class="apidocSignatureSpan">proxyquire.is.</span>String
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxyquire.proxyquire">module proxyquire.proxyquire</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.proxyquire">
            function <span class="apidocSignatureSpan">proxyquire.</span>proxyquire
            <span class="apidocSignatureSpan">(parent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxyquire.proxyquire.prototype">module proxyquire.proxyquire.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype._disableCache">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_disableCache
            <span class="apidocSignatureSpan">(module, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype._disableGlobalCache">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_disableGlobalCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype._disableModuleCache">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_disableModuleCache
            <span class="apidocSignatureSpan">(path, module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype._overrideExtensionHandlers">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_overrideExtensionHandlers
            <span class="apidocSignatureSpan">(module, stubs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype._require">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_require
            <span class="apidocSignatureSpan">(module, stubs, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype._withoutCache">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_withoutCache
            <span class="apidocSignatureSpan">(module, stubs, path, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype.callThru">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>callThru
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype.load">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>load
            <span class="apidocSignatureSpan">(request, stubs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype.noCallThru">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>noCallThru
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype.noPreserveCache">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>noPreserveCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire.prototype.preserveCache">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>preserveCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxyquire.proxyquire_error">module proxyquire.proxyquire_error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire_error.proxyquire_error">
            function <span class="apidocSignatureSpan">proxyquire.</span>proxyquire_error
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxyquire.proxyquire_error.super_">
            function <span class="apidocSignatureSpan">proxyquire.proxyquire_error.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxyquire" id="apidoc.module.proxyquire">module proxyquire</a></h1>


    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire" id="apidoc.element.proxyquire.proxyquire">
        function <span class="apidocSignatureSpan"></span>proxyquire
        <span class="apidocSignatureSpan">(parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Proxyquire(parent) {
  var self = this
    , fn = self.load.bind(self)
    , proto = Proxyquire.prototype
    ;

  this._parent = parent;
  this._preserveCache = true;

  Object.keys(proto)
    .forEach(function (key) {
      if (is.Function(proto[key])) fn[key] = proto[key].bind(self);
    });

  self.fn = fn;
  return fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire._disableCache" id="apidoc.element.proxyquire._disableCache">
        function <span class="apidocSignatureSpan">proxyquire.</span>_disableCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_disableCache = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Module._load(path, module);
}
};

Proxyquire.prototype._withoutCache = function(module, stubs, path, func) {
// Temporarily disable the cache - either per-module or globally if we have global stubs
var restoreCache = this.<span class="apidocCodeKeywordSpan">_disableCache</span>(module, path);

// Override all require extension handlers
var restoreExtensionHandlers = this._overrideExtensionHandlers(module, stubs);

try {
  // Execute the function that needs the module cache disabled
  return func();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire._disableGlobalCache" id="apidoc.element.proxyquire._disableGlobalCache">
        function <span class="apidocSignatureSpan">proxyquire.</span>_disableGlobalCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_disableGlobalCache = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Proxyquire.prototype._disableCache = function(module, path) {
  if (this._containsGlobal) {
    // empty the require cache because if we are stubbing C but requiring A,
    // and if A requires B and B requires C, then B and C might be cached already
    // and we'll never get the chance to return our stub
    return this.<span class="apidocCodeKeywordSpan">_disableGlobalCache</span>();
  }

  // Temporarily delete the SUT from the require cache
  return this._disableModuleCache(path, module);
};

Proxyquire.prototype._disableGlobalCache = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire._disableModuleCache" id="apidoc.element.proxyquire._disableModuleCache">
        function <span class="apidocSignatureSpan">proxyquire.</span>_disableModuleCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_disableModuleCache = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // empty the require cache because if we are stubbing C but requiring A,
  // and if A requires B and B requires C, then B and C might be cached already
  // and we'll never get the chance to return our stub
  return this._disableGlobalCache();
}

// Temporarily delete the SUT from the require cache
return this.<span class="apidocCodeKeywordSpan">_disableModuleCache</span>(path, module);
};

Proxyquire.prototype._disableGlobalCache = function() {
var cache = require.cache;
require.cache = Module._cache = {};

for (var id in cache) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire._overrideExtensionHandlers" id="apidoc.element.proxyquire._overrideExtensionHandlers">
        function <span class="apidocSignatureSpan">proxyquire.</span>_overrideExtensionHandlers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_overrideExtensionHandlers = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Proxyquire.prototype._withoutCache = function(module, stubs, path, func) {
// Temporarily disable the cache - either per-module or globally if we have global stubs
var restoreCache = this._disableCache(module, path);

// Override all require extension handlers
var restoreExtensionHandlers = this.<span class="apidocCodeKeywordSpan">_overrideExtensionHandlers</span>(module, stubs);

try {
  // Execute the function that needs the module cache disabled
  return func();
} finally {
  // Restore the cache if we are preserving it
  if (this._preserveCache) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire._require" id="apidoc.element.proxyquire._require">
        function <span class="apidocSignatureSpan">proxyquire.</span>_require
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_require = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire._withoutCache" id="apidoc.element.proxyquire._withoutCache">
        function <span class="apidocSignatureSpan">proxyquire.</span>_withoutCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withoutCache = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (hasOwnProperty.call(stub, '@runtimeGlobal')) {
    this._containsGlobal = true;
    this._containsRuntimeGlobal = true;
  }
}

// Ignore the module cache when return the requested module
return this.<span class="apidocCodeKeywordSpan">_withoutCache</span>(this._parent, stubs, request, this._parent.require.bind(this
._parent, request));
};

// This replaces a module's require function
Proxyquire.prototype._require = function(module, stubs, path) {
assert(typeof path === 'string', 'path must be a string');
assert(path, 'missing path');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.callThru" id="apidoc.element.proxyquire.callThru">
        function <span class="apidocSignatureSpan">proxyquire.</span>callThru
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callThru = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// all stubs resolved by proxyquireNonStrict will call through by default
var proxyquireNonStrict = require('proxyquire');
```

### Re-enable call thru for all future stubs resolved by a proxyquire instance

```javascript
proxyquire.<span class="apidocCodeKeywordSpan">callThru</span>();
```

**Call thru configurations per module override `callThru()`:**

Passing `@noCallThru: false` when configuring modules will override `noCallThru()`:

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.compat" id="apidoc.element.proxyquire.compat">
        function <span class="apidocSignatureSpan">proxyquire.</span>compat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compat = function () {
  throw new Error("Proxyquire compat mode has been removed. Please update your code to use the new API or pin the version in your
 package.json file to ~0.6");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.load" id="apidoc.element.proxyquire.load">
        function <span class="apidocSignatureSpan">proxyquire.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Call thru configurations per module override `callThru()`:**

Passing `@noCallThru: false` when configuring modules will override `noCallThru()`:

```javascript
var foo = proxyquire
    .noCallThru()
    .<span class="apidocCodeKeywordSpan">load</span>('./foo', {

  // no calls to original './bar' methods will be made
  './bar' : { toAtm: function (val) { ... } }

  // for 'path' module they will be made
, path: {
    extname: function (file) { ... }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.noCallThru" id="apidoc.element.proxyquire.noCallThru">
        function <span class="apidocSignatureSpan">proxyquire.</span>noCallThru
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noCallThru = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

### Prevent call thru for all future stubs resolved by a proxyquire instance

```javascript
// all stubs resolved by proxyquireStrict will not call through by default
var proxyquireStrict = require('proxyquire').<span class="apidocCodeKeywordSpan">noCallThru</span>();

// all stubs resolved by proxyquireNonStrict will call through by default
var proxyquireNonStrict = require('proxyquire');
```

### Re-enable call thru for all future stubs resolved by a proxyquire instance
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.noPreserveCache" id="apidoc.element.proxyquire.noPreserveCache">
        function <span class="apidocSignatureSpan">proxyquire.</span>noPreserveCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noPreserveCache = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For some tests however you need to ensure that the module gets loaded fresh everytime, i.e. if that causes initializing
some dependency or some module state.

For this purpose proxyquire exposes the `noPreserveCache` function.

```js
// ensure we don't get any module from the cache, but to load it fresh every time
var proxyquire = require('proxyquire').<span class="apidocCodeKeywordSpan">noPreserveCache</span>();

var foo1 = proxyquire('./foo', stubs);
var foo2 = proxyquire('./foo', stubs);
var foo3 = require('./foo');

// foo1, foo2 and foo3 are different instances of the same module
assert.notEqual(foo1, foo2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.preserveCache" id="apidoc.element.proxyquire.preserveCache">
        function <span class="apidocSignatureSpan">proxyquire.</span>preserveCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">preserveCache = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
assert.notEqual(foo1, foo2);
assert.notEqual(foo1, foo3);
```

`require.preserveCache` allows you to restore the behavior to match nodejs's `require` again.

```js
proxyquire.<span class="apidocCodeKeywordSpan">preserveCache</span>();

var foo1 = proxyquire('./foo', stubs);
var foo2 = proxyquire('./foo', stubs);
var foo3 = require('./foo');

// foo1, foo2 and foo3 are the same instance
assert.equal(foo1, foo2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire_error" id="apidoc.element.proxyquire.proxyquire_error">
        function <span class="apidocSignatureSpan">proxyquire.</span>proxyquire_error
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyquireError(msg) {
  this.name = 'ProxyquireError';
  Error.captureStackTrace(this, ProxyquireError);
  this.message = msg || 'An error occurred inside proxyquire.';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxyquire.is" id="apidoc.module.proxyquire.is">module proxyquire.is</a></h1>


    <h2>
        <a href="#apidoc.element.proxyquire.is.Arguments" id="apidoc.element.proxyquire.is.Arguments">
        function <span class="apidocSignatureSpan">proxyquire.is.</span>Arguments
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Arguments = function (obj) {
  return Object.prototype.toString.call(obj) == '[object ' + name + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.is.Date" id="apidoc.element.proxyquire.is.Date">
        function <span class="apidocSignatureSpan">proxyquire.is.</span>Date
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Date = function (obj) {
  return Object.prototype.toString.call(obj) == '[object ' + name + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.is.Function" id="apidoc.element.proxyquire.is.Function">
        function <span class="apidocSignatureSpan">proxyquire.is.</span>Function
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Function = function (obj) {
  return Object.prototype.toString.call(obj) == '[object ' + name + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ;

  this._parent = parent;
  this._preserveCache = true;

  Object.keys(proto)
    .forEach(function (key) {
      if (is.<span class="apidocCodeKeywordSpan">Function</span>(proto[key])) fn[key] = proto[key].bind(self);
    });

  self.fn = fn;
  return fn;
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.is.Number" id="apidoc.element.proxyquire.is.Number">
        function <span class="apidocSignatureSpan">proxyquire.is.</span>Number
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Number = function (obj) {
  return Object.prototype.toString.call(obj) == '[object ' + name + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.is.Object" id="apidoc.element.proxyquire.is.Object">
        function <span class="apidocSignatureSpan">proxyquire.is.</span>Object
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Object = function (obj) {
  return obj === new Object(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!stubs)
      return 'Missing argument: "stubs". If no stubbing is needed, use regular require instead.';

    if (!is.String(request))
      return 'Invalid argument: "request". Needs to be a requirable string that is the module to load.';

    if (!is.<span class="apidocCodeKeywordSpan">Object</span>(stubs))
      return 'Invalid argument: "stubs". Needs to be an object containing overrides e.g., {"path": { extname
: function () { ... } } }.';
  })();

  if (msg) throw new ProxyquireError(msg);
}

function Proxyquire(parent) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.is.RegExp" id="apidoc.element.proxyquire.is.RegExp">
        function <span class="apidocSignatureSpan">proxyquire.is.</span>RegExp
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RegExp = function (obj) {
  return Object.prototype.toString.call(obj) == '[object ' + name + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.is.String" id="apidoc.element.proxyquire.is.String">
        function <span class="apidocSignatureSpan">proxyquire.is.</span>String
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">String = function (obj) {
  return Object.prototype.toString.call(obj) == '[object ' + name + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var msg = (function getMessage() {
  if (!request)
    return 'Missing argument: "request". Need it to resolve desired module.';

  if (!stubs)
    return 'Missing argument: "stubs". If no stubbing is needed, use regular require instead.';

  if (!is.<span class="apidocCodeKeywordSpan">String</span>(request))
    return 'Invalid argument: "request". Needs to be a requirable string that is the module to load.';

  if (!is.Object(stubs))
    return 'Invalid argument: "stubs". Needs to be an object containing overrides e.g., {"path": { extname
: function () { ... } } }.';
})();

if (msg) throw new ProxyquireError(msg);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxyquire.proxyquire" id="apidoc.module.proxyquire.proxyquire">module proxyquire.proxyquire</a></h1>


    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.proxyquire" id="apidoc.element.proxyquire.proxyquire.proxyquire">
        function <span class="apidocSignatureSpan">proxyquire.</span>proxyquire
        <span class="apidocSignatureSpan">(parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Proxyquire(parent) {
  var self = this
    , fn = self.load.bind(self)
    , proto = Proxyquire.prototype
    ;

  this._parent = parent;
  this._preserveCache = true;

  Object.keys(proto)
    .forEach(function (key) {
      if (is.Function(proto[key])) fn[key] = proto[key].bind(self);
    });

  self.fn = fn;
  return fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxyquire.proxyquire.prototype" id="apidoc.module.proxyquire.proxyquire.prototype">module proxyquire.proxyquire.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype._disableCache" id="apidoc.element.proxyquire.proxyquire.prototype._disableCache">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_disableCache
        <span class="apidocSignatureSpan">(module, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_disableCache = function (module, path) {
  if (this._containsGlobal) {
    // empty the require cache because if we are stubbing C but requiring A,
    // and if A requires B and B requires C, then B and C might be cached already
    // and we'll never get the chance to return our stub
    return this._disableGlobalCache();
  }

  // Temporarily delete the SUT from the require cache
  return this._disableModuleCache(path, module);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  return Module._load(path, module);
}
};

Proxyquire.prototype._withoutCache = function(module, stubs, path, func) {
// Temporarily disable the cache - either per-module or globally if we have global stubs
var restoreCache = this.<span class="apidocCodeKeywordSpan">_disableCache</span>(module, path);

// Override all require extension handlers
var restoreExtensionHandlers = this._overrideExtensionHandlers(module, stubs);

try {
  // Execute the function that needs the module cache disabled
  return func();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype._disableGlobalCache" id="apidoc.element.proxyquire.proxyquire.prototype._disableGlobalCache">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_disableGlobalCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_disableGlobalCache = function () {
  var cache = require.cache;
  require.cache = Module._cache = {};

  for (var id in cache) {
    // Keep native modules (i.e. `.node` files).
    // Otherwise, Node.js would throw a â€œModule did not self-registerâ€
    // error upon requiring it a second time.
    // See https://github.com/nodejs/node/issues/5016.
    if (/\.node$/.test(id)) {
      require.cache[id] = cache[id];
    }
  }

  // Return a function that will undo what we just did
  return function() {
    // Keep native modules which were added to the cache in the meantime.
    for (var id in require.cache) {
      if (/\.node$/.test(id)) {
        cache[id] = require.cache[id]
      }
    }

    require.cache = Module._cache = cache;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Proxyquire.prototype._disableCache = function(module, path) {
  if (this._containsGlobal) {
    // empty the require cache because if we are stubbing C but requiring A,
    // and if A requires B and B requires C, then B and C might be cached already
    // and we'll never get the chance to return our stub
    return this.<span class="apidocCodeKeywordSpan">_disableGlobalCache</span>();
  }

  // Temporarily delete the SUT from the require cache
  return this._disableModuleCache(path, module);
};

Proxyquire.prototype._disableGlobalCache = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype._disableModuleCache" id="apidoc.element.proxyquire.proxyquire.prototype._disableModuleCache">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_disableModuleCache
        <span class="apidocSignatureSpan">(path, module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_disableModuleCache = function (path, module) {
  // Find the ID (location) of the SUT, relative to the parent
  var id = Module._resolveFilename(path, module);

  var cached = Module._cache[id];
  delete Module._cache[id];

  // Return a function that will undo what we just did
  return function() {
    if (cached) {
      Module._cache[id] = cached;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // empty the require cache because if we are stubbing C but requiring A,
  // and if A requires B and B requires C, then B and C might be cached already
  // and we'll never get the chance to return our stub
  return this._disableGlobalCache();
}

// Temporarily delete the SUT from the require cache
return this.<span class="apidocCodeKeywordSpan">_disableModuleCache</span>(path, module);
};

Proxyquire.prototype._disableGlobalCache = function() {
var cache = require.cache;
require.cache = Module._cache = {};

for (var id in cache) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype._overrideExtensionHandlers" id="apidoc.element.proxyquire.proxyquire.prototype._overrideExtensionHandlers">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_overrideExtensionHandlers
        <span class="apidocSignatureSpan">(module, stubs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_overrideExtensionHandlers = function (module, stubs) {
  var originalExtensions = {};
  var self = this;

  Object.keys(require.extensions).forEach(function(extension) {
    // Store the original so we can restore it later
    if (!originalExtensions[extension]) {
      originalExtensions[extension] = require.extensions[extension];
    }

    // Override the default handler for the requested file extension
    require.extensions[extension] = function(module, filename) {
      // Override the require method for this module
      module.require = self._require.bind(self, module, stubs);

      return originalExtensions[extension](module, filename);
    };
  });

  // Return a function that will undo what we just did
  return function() {
    Object.keys(originalExtensions).forEach(function(extension) {
      require.extensions[extension] = originalExtensions[extension];
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Proxyquire.prototype._withoutCache = function(module, stubs, path, func) {
// Temporarily disable the cache - either per-module or globally if we have global stubs
var restoreCache = this._disableCache(module, path);

// Override all require extension handlers
var restoreExtensionHandlers = this.<span class="apidocCodeKeywordSpan">_overrideExtensionHandlers</span>(module, stubs);

try {
  // Execute the function that needs the module cache disabled
  return func();
} finally {
  // Restore the cache if we are preserving it
  if (this._preserveCache) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype._require" id="apidoc.element.proxyquire.proxyquire.prototype._require">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_require
        <span class="apidocSignatureSpan">(module, stubs, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_require = function (module, stubs, path) {
  assert(typeof path === 'string', 'path must be a string');
  assert(path, 'missing path');

  if (hasOwnProperty.call(stubs, path)) {
    var stub = stubs[path];

    if (stub === null) {
      // Mimic the module-not-found exception thrown by node.js.
      throw moduleNotFoundError(path);
    }

    if (hasOwnProperty.call(stub, '@noCallThru') ? !stub['@noCallThru'] : !this._noCallThru) {
      fillMissingKeys(stub, Module._load(path, module));
    }

    // We are top level or this stub is marked as global
    if (module.parent == this._parent || hasOwnProperty.call(stub, '@global') || hasOwnProperty.call(stub, '@runtimeGlobal')) {
      return stub;
    }
  }

  // Only ignore the cache if we have global stubs
  if (this._containsRuntimeGlobal) {
    return this._withoutCache(module, stubs, path, Module._load.bind(Module, path, module));
  } else {
    return Module._load(path, module);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype._withoutCache" id="apidoc.element.proxyquire.proxyquire.prototype._withoutCache">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>_withoutCache
        <span class="apidocSignatureSpan">(module, stubs, path, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_withoutCache = function (module, stubs, path, func) {
  // Temporarily disable the cache - either per-module or globally if we have global stubs
  var restoreCache = this._disableCache(module, path);

  // Override all require extension handlers
  var restoreExtensionHandlers = this._overrideExtensionHandlers(module, stubs);

  try {
    // Execute the function that needs the module cache disabled
    return func();
  } finally {
    // Restore the cache if we are preserving it
    if (this._preserveCache) {
      restoreCache();
    } else {
      var id = Module._resolveFilename(path, module);
      var stubIds = Object.keys(stubs).map(function (stubPath) {
        try {
          return resolve.sync(stubPath, {
            basedir: dirname(id),
            extensions: Object.keys(require.extensions),
            paths: Module.globalPaths
          })
        } catch (_) {}
      });
      var ids = [id].concat(stubIds.filter(Boolean));

      ids.forEach(function (id) {
        delete require.cache[id];
      });
    }

    // Finally restore the original extension handlers
    restoreExtensionHandlers();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (hasOwnProperty.call(stub, '@runtimeGlobal')) {
    this._containsGlobal = true;
    this._containsRuntimeGlobal = true;
  }
}

// Ignore the module cache when return the requested module
return this.<span class="apidocCodeKeywordSpan">_withoutCache</span>(this._parent, stubs, request, this._parent.require.bind(this
._parent, request));
};

// This replaces a module's require function
Proxyquire.prototype._require = function(module, stubs, path) {
assert(typeof path === 'string', 'path must be a string');
assert(path, 'missing path');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype.callThru" id="apidoc.element.proxyquire.proxyquire.prototype.callThru">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>callThru
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callThru = function () {
  this._noCallThru = false;
  return this.fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// all stubs resolved by proxyquireNonStrict will call through by default
var proxyquireNonStrict = require('proxyquire');
```

### Re-enable call thru for all future stubs resolved by a proxyquire instance

```javascript
proxyquire.<span class="apidocCodeKeywordSpan">callThru</span>();
```

**Call thru configurations per module override `callThru()`:**

Passing `@noCallThru: false` when configuring modules will override `noCallThru()`:

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype.load" id="apidoc.element.proxyquire.proxyquire.prototype.load">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>load
        <span class="apidocSignatureSpan">(request, stubs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (request, stubs) {
  validateArguments(request, stubs);

  // Find out if any of the passed stubs are global overrides
  for (var key in stubs) {
    var stub = stubs[key];

    if (stub === null) continue;

    if (typeof stub === 'undefined') {
      throw new ProxyquireError('Invalid stub: "' + key + '" cannot be undefined');
    }

    if (hasOwnProperty.call(stub, '@global')) {
      this._containsGlobal = true;
    }

    if (hasOwnProperty.call(stub, '@runtimeGlobal')) {
      this._containsGlobal = true;
      this._containsRuntimeGlobal = true;
    }
  }

  // Ignore the module cache when return the requested module
  return this._withoutCache(this._parent, stubs, request, this._parent.require.bind(this._parent, request));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Call thru configurations per module override `callThru()`:**

Passing `@noCallThru: false` when configuring modules will override `noCallThru()`:

```javascript
var foo = proxyquire
    .noCallThru()
    .<span class="apidocCodeKeywordSpan">load</span>('./foo', {

  // no calls to original './bar' methods will be made
  './bar' : { toAtm: function (val) { ... } }

  // for 'path' module they will be made
, path: {
    extname: function (file) { ... }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype.noCallThru" id="apidoc.element.proxyquire.proxyquire.prototype.noCallThru">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>noCallThru
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noCallThru = function () {
  this._noCallThru = true;
  return this.fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

### Prevent call thru for all future stubs resolved by a proxyquire instance

```javascript
// all stubs resolved by proxyquireStrict will not call through by default
var proxyquireStrict = require('proxyquire').<span class="apidocCodeKeywordSpan">noCallThru</span>();

// all stubs resolved by proxyquireNonStrict will call through by default
var proxyquireNonStrict = require('proxyquire');
```

### Re-enable call thru for all future stubs resolved by a proxyquire instance
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype.noPreserveCache" id="apidoc.element.proxyquire.proxyquire.prototype.noPreserveCache">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>noPreserveCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noPreserveCache = function () {
  this._preserveCache = false;
  return this.fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For some tests however you need to ensure that the module gets loaded fresh everytime, i.e. if that causes initializing
some dependency or some module state.

For this purpose proxyquire exposes the `noPreserveCache` function.

```js
// ensure we don't get any module from the cache, but to load it fresh every time
var proxyquire = require('proxyquire').<span class="apidocCodeKeywordSpan">noPreserveCache</span>();

var foo1 = proxyquire('./foo', stubs);
var foo2 = proxyquire('./foo', stubs);
var foo3 = require('./foo');

// foo1, foo2 and foo3 are different instances of the same module
assert.notEqual(foo1, foo2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire.prototype.preserveCache" id="apidoc.element.proxyquire.proxyquire.prototype.preserveCache">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire.prototype.</span>preserveCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">preserveCache = function () {
  this._preserveCache = true;
  return this.fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
assert.notEqual(foo1, foo2);
assert.notEqual(foo1, foo3);
```

`require.preserveCache` allows you to restore the behavior to match nodejs's `require` again.

```js
proxyquire.<span class="apidocCodeKeywordSpan">preserveCache</span>();

var foo1 = proxyquire('./foo', stubs);
var foo2 = proxyquire('./foo', stubs);
var foo3 = require('./foo');

// foo1, foo2 and foo3 are the same instance
assert.equal(foo1, foo2);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxyquire.proxyquire_error" id="apidoc.module.proxyquire.proxyquire_error">module proxyquire.proxyquire_error</a></h1>


    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire_error.proxyquire_error" id="apidoc.element.proxyquire.proxyquire_error.proxyquire_error">
        function <span class="apidocSignatureSpan">proxyquire.</span>proxyquire_error
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyquireError(msg) {
  this.name = 'ProxyquireError';
  Error.captureStackTrace(this, ProxyquireError);
  this.message = msg || 'An error occurred inside proxyquire.';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxyquire.proxyquire_error.super_" id="apidoc.element.proxyquire.proxyquire_error.super_">
        function <span class="apidocSignatureSpan">proxyquire.proxyquire_error.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>